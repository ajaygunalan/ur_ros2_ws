/**
 *
 * \file particle_filter_vel_noise_class.hpp
 *
 * \brief Particle filter definition for 3D photoacoustic visual servoing system modeling velocity with noise
 *
 * \details This system samples and updates particles in the instantaneous transducer frame, with limits on the
 * locations of particles based on the transducer geometry. At each step, the system propagates the particles based on
 * the previous robot motion with noise-based particle velocity.
 *
 * \author Mardava Gubbi <mgubbi1@jhu.edu>
 *
 * \references
 * 1. Elfring, et al., "Particle filters: A hands-on tutorial.", Sensors 21.2 (2021): 438.
 * 2. Gubbi, et al., IEEE T-UFFC 2024.
 */
#ifndef PULSE_PARTICLE_FILTER_VEL_NOISE_CLASS_HPP
#define PULSE_PARTICLE_FILTER_VEL_NOISE_CLASS_HPP

#include <cmath>
#include <random>
#include <vector>

#include <geometry_msgs/Point32.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/TransformStamped.h>
#include <sensor_msgs/PointCloud.h>
#include <tf2_eigen/tf2_eigen.h>

#include "pulse_estimation_filters/estimation_filter_class.hpp"

#define PARTICLE_WEIGHT_SUM_THRESH 1.0e-15

namespace pulse_est
{
class ParticleFilterVelNoise : protected EstimationFilter
{
protected:
  /**
   * \brief Process noise injected into propagation of particles from one sampling instant to the next
   *
   * \details We assume the point source travels with a speed of around 1 cm/s, so we add a process noise of 1 mm in
   * each direction, assuming a 10 Hz frame rate.
   */
  double process_noise_std;

  /**
   * \brief Measurement noise of detections output by point source localization systems.
   *
   * \details This should be fetched from simulation results. Typically around 2 mm in each direction. [2]
   */
  double measurement_noise_std;

  /**
   * \brief Extreme negative lateral displacement of point source relative to transducer
   */
  double x_min;

  /**
   * \brief Extreme positive lateral displacement of point source relative to transducer
   */
  double x_max;

  /**
   * \brief Extreme negative elevation displacement of point source relative to transducer
   */
  double y_min;

  /**
   * \brief Extreme positive elevation displacement of point source relative to transducer
   */
  double y_max;

  /**
   * \brief Minimum axial displacement of point source relative to transducer
   */
  double z_min;

  /**
   * \brief Maximum axial displacement of point source relative to transducer
   */
  double z_max;

  /**
   * \brief Number of particles used by particle filter
   */
  int number_of_particles;

  /**
   * \brief Random number generation engine
   */
  std::default_random_engine rand_num_gen;

  /**
   * \brief Normally distributed random number generators for process noise injection.
   */
  std::normal_distribution<double>* x_proc_gen;
  std::normal_distribution<double>* y_proc_gen;
  std::normal_distribution<double>* z_proc_gen;

  /**
   * \brief Uniformly distributed random number generator for particle resampling.
   */
  std::uniform_real_distribution<double>* cdf_rand_gen;

  /**
   * \brief Variables related to current particle positions, velocities, and weights
   */
  Eigen::MatrixXd particle_positions_mat;
  std::vector<double> particle_weights;
  // Eigen::MatrixXd particle_velocities_mat;

  /**
   * \brief Inverse matrix required to compute Gaussian mixture-based probability density function during update.
   */
  Eigen::Matrix3d particle_cov_mat_inv;

  /**
   * \brief Publisher of point cloud generated by particle filter
   */
  ros::Publisher weight_update_pub;
  ros::Publisher resampled_pub;

  /**
   *
   * \brief Perform a binary search on the given array for the given value.
   *
   * \details We assume that the size of `x_vec` is a power of 2.
   *
   * \return The index of the sample from the array closest to the given value
   *
   */
  int binarySearch(std::vector<double> x_vec, double x_val);

  /**
   *
   * \brief Compute the effective sample size using Eq. (18) in [1].
   *
   * \details This function also publishes the effective sample size to a ROS topic.
   *
   */
  void computeEffectiveSampleSize(void);

  /**
   *
   * \brief Initialize the sampling of particles using a uniform random distribution along each axis.
   *
   */
  void initializeParticles(void);

  /**
   *
   * \brief Propagate the motion of particles in the base frame using noise for velocity
   *
   */
  void propagateParticlePositions(void);

  /**
   *
   * \brief Resample particles using the previously computed posteriors
   *
   * \details Multinomial resampling described by Elfring et al. [1]
   *
   */
  void resampleParticles(void);

  /**
   *
   * \brief Update particle weights from the given measurements using a pre-determined algorithm
   *
   * \details This implementation of the weight-update takes each particle position, and computes the weighted sum of
   * Gaussians around each detection. The confidences scores of the detections form the weights of the weighted sum.
   *
   * \arg[in] msg Message containing detections output by photoacoustic point source localization system
   * \arg[in] probe_pose_base_eig Transform from probe frame to base frame to be applied to network detections
   *
   */
  void updateParticleWeights(vision_msgs::Detection2DArray msg, Eigen::Isometry3d probe_pose_base_eig);

  /**
   *
   * \brief Cycle the particles within the current transducer FoV if required.
   *
   */
  void validateParticlePositions(Eigen::Isometry3d base_pose_probe_eig, Eigen::Isometry3d probe_pose_base_eig);

public:
  /**
   *
   * \brief Construct an object of the type `ParticleFilterVelNoise`.
   *
   * \arg[in] nh The ROS node handler
   *
   */
  ParticleFilterVelNoise(ros::NodeHandle& nh);

  /**
   *
   * \brief Update function for particle filter
   *
   * \details This function propagates the particles from the current particle frame (coincident with the previous probe
   * frame) to the current probe frame.
   *
   * \arg[in] msg Message containing detections output by photoacoustic point source localization system
   *
   */
  void detectionSubscriberCallback(vision_msgs::Detection2DArray msg) override;
};
}  // namespace pulse_est

#endif /* PULSE_PARTICLE_FILTER_VEL_NOISE_CLASS_HPP */
